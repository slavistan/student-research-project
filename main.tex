\documentclass{article}

% Packages
\usepackage[utf8]{inputenc} % Required for German umlauts
% SVG
\usepackage{svg}
% Bib
\usepackage[backend=biber]{biblatex}
\addbibresource{bib/bibliography.bib}

%%
%% Custom commands
%%


%
% Tikz Setup
%
\usepackage[customcolors]{hf-tikz}

\tikzset{style green/.style={
    set fill color=green!50!lime!60,
    set border color=white,
  },
  style cyan/.style={
    set fill color=cyan!90!blue!60,
    set border color=white,
  },
  style orange/.style={
    set fill color=orange!80!red!60,
    set border color=white,
  },
  hor/.style={
    above left offset={-0.15,0.31},
    below right offset={0.15,-0.125},
    #1
  },
  ver/.style={
    above left offset={-0.1,0.3},
    below right offset={0.15,-0.15},
    #1
  }
}

\author{Stanislaw HÃ¼ll}
\title{Student Research Project}
\date{2018-11-11}
\begin{document}

\maketitle

\section{Introduction}

  \subsection{Compressed Sparse Row Format}
    It is a widely used storage format for sparse matrices which does not make assumptions about the matrix's shape
    or its distribution of non-zero elements in contrast to other popular sparse matrix storage formats such as the
    the diagonal storage format or ELLPACK. It optimizes the storage requirements of general sparse matrices with
    respect to the naive coordinate format (COO) in that each non-zero's row index is no longer explicitly stored.

    The CSR format consists of three dense arrays:

    The values array stores the numerical value for each non-zero entry in the matrix while their column index is stored
    in the associated column-index array. A third array, the row-pointer array, encodes the beginning of each row's
    section within the values and column-index arrays, i.e. it stores the offset of each row's first non-zero element
    into the two previous arrays. Thus the CSR format optimizes the storage requirements of general sparse matrices with
    respect to the naive coordinate format (COO) in that each-nonzero's row index is no longer explicitly stored,
    shrinking the size of the third array from one entry per non-zero element to a single entry per row.

    \input{fig/csr_example.tex}

    By convention, the non-zeros are stored row-wise in ordered fashion from left to right implying that each row's
    section within the column-index array is sorted in ascending fashion. Additionally, the row-pointer array contains
    an additional element denoting the total number of non-zero elements in the structure. Note that sometimes a
    different nomenclature is utilized in the existing literature, referring to the arrays as A (values), JA
    (column-indices) and IA (row-pointers), respectively \cite{sparskit}.

    The CSR format's salient feature is its direct access to a row's non-zero elements' values and column indices making
    it particularly well suited for matrix-vector-multiplication utilizing a conventional row-by-column computation
    scheme. Aside of this feature storing the non-zero elements row by row as opposed to column by column is, to a
    certain degree, arbitrary and thus exist numerical libraries and toolkits such as the Eigen C++ library
    \cite{eigen:website} or the Harwell-Boeing sparse matrix collection \cite{harwell-boeing} which utilize the CSR
    format's conjugate, the compressed sparse column format (CSC), as their default means of representing sparse
    matrices.

  \subsection{Structured Grid Matrices}

    Structured grid computations are ubiquitously used for physical simulations for computational fluid dynamics,
    electrodynamics and astrophysics.  In contrast to unstructured grids the regularity inherent to structured grids
    allows for very efficient numerical treatment, such that even in cases where sufficiently complex geometries
    prohibit the decomposition of the target domain into a single overarching structured grid the domain is often
    tesselated into an unstructured configuration, with the tiles being filled by independent structured grids
    \cite{Badcock2000}.

    To derive an approximate solution to a physical system's set of partial differential equations
    the PDEs are discretized on the structured grid by approximating the differential operators by algebraic
    expressions. A promiment example is the Cartesian finite-difference approximation of the Laplacian operator.
    The discretization step yields a linear problem $A x = b$ in which the right-hand side $b$ depends only on the
    boundary conditions and is thus known.

    (((TODO))) The solution of this linear system by iterative means requires that, starting at an initial guess $x_0$,
    a stencil operation is applied to each node, i.e. its new value is determined by a weighted sum of the current
    values of its adjacent nodes. Which nodes are considered adjacent depends on the approximation of the differential
    operators, but in general the pattern is symmetric with respect to the node in question while the individual weights
    of the weighted sum might change from node to node. The stencil corresponding to the finite-difference Laplacian is
    the symmetric 5-point or 7-point stencil for 2D or 3D grids, respectively.

    Evidently, the stencil operation across the grid is equivalent to a multiplication with the grid's adjacency matrix,
    whose non-zero entries encode the adjacency relation of the stencil across the whole matrix and whose numeric values
    are the weighted sum's weights. These adjacency matrices have a very characteristic structure, whose exact shape
    depends on the type of boundary condition underlying the physical system's PDEs and on the stencil's geometry. In
    general, they are symmetric and consist of as many diagonals as there are nodes in the stencil. The diagonals are almost
    completely dense with exceptions arising at nodes corresponding to the grid's boundaries, i.e. its corners and
    sides, where the adjacency pattern is disturbed by missing nodes as in the case of Dirichlet boundary conditions.
    Adjacency matrices are symmetric and have one row and column per node in the grid.

    \input{fig/stencil_adj_mat.tex}

    TODO: Bisher nur finite difference, was ist mit FEM?

    Arise as finite difference adjacency matrices from discretization of elliptic type PDE (SPARSKIT 7.1)
      and structured mesh finite element matrices.
    Are (locally) structured.
    "Almost" diagonal --> DIA not the best. [Godwin2013: p9!!!]

\section{Three-fold compressed sparse row}
  Improve upon CSR format utilizing domain knowledge about structured grid matrices.
  Stencil operation is applied multiple times during the solution, thus matvecmult speed is critical.
  \subsection{Data layout and storage scheme}
    Starts out at a CSR representation. This section explains the general storage scheme. Its usage and motivation will be clarified in the next section.
    Applies compression idea of CSR to the non-zeros' value array and column index array separately (... motivation?).
    V stores the numerical value of each non-zero entry, VS stores an index-pointer into V to each initial element of a row's section within V.

      Example: Compressed and uncompressed values (Matrix <-> Varrays)

    Column index information is split into three arrays.
    Peg-index: Column index of each row's first non-zero. (JPeg)
    jrel: Column indices relative to their row's peg-index (:= 'index pattern') (JRel)
    jrelstart: Index-pointer into JRel to each initial element of a row's section within JRel.

      Example: Compressed and uncompressed column indices (Matrix <-> Varrays)

    High-level view of the data organization:
    (A) Data representing the matrix's non-zero elements
      A real array V  and vstart;

    (B) Data representing non-zero elements' column indices
      jrel and jrelstart and peg-index

    (C) Row pointers (as in CSR) row-pointers

  \subsection{Compression mechanism}

  \subsection{Algorithms}

    \subsubsection{Matvecmult}
      improves locality (--> Performance)

    \subsubsection{Element access A[i;j]}
      binary lookup
\section{Performance Benchmarks}
  Measure performance in terms of (1) data compression ratio and (2) arithmetic performance (matvecmult)

  \subsection{Generation of structured grid adjacency matrices as test matrices}

  \subsection{Data compression}

  \subsection{Arithmetic performance (matvecmult)}

\section{Summary}
  Advantages: General purpose, good performance, parallel scalability
  Disadv: Static structure (cannot add/remove elements)

\printbibliography
\end{document}
